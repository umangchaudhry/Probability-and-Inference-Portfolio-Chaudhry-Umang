---
title: "Blog Post - Quantile Precision"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(tidyverse)
library(janitor)
library(ggplot2)
```


# Which quantiles of a continuous distribution can one estimate with more precision?

The distribution of data is an important characteristic to understand in Data Science. The median is an important quantity in data analysis. It represents the middle value of the data distribution. Estimates of the median, however, have a degree of uncertainty because of several reasons. The first is that the estimates are calculated from a finite sample and second is that the data distribution of the underlying data is generally unknown. One important roles of a data scientist is to quantify and to communicate the degree of uncertainty in his or her data analysis.

In this blog post, we will determine the uncertainty that exists when using certain quantiles of a continous distribution. Because of the reasons stated above, each quantile we calculate will have some uncertainty, some having more so than others. As in previous blog posts, we will be using simulations to explore this topic. 

We will be looking at the following continous probability distributions in this post: 

1. Standard Normal Distributions
2. Exponential Distributions
3. Mixture Distributions

Details about how each distribution works will be discussed before we dig into determining the uncertainties amongst different quantiles of the data generated by these distributions. 

# Setup

In order to explore each distribution, we will create the following graph. The sampling distribution for the quantiles is generated by repeatedly calculating the quantiles from random samples of size N. For the purposes of this blog post, we will let N = 200. We will then calculate the length of the middle 95% of the sampling distribution by calculating the difference between 2.5% and 97.5% percentiles of the sampling distribution. The empirical sampling distribution will be set to at least 5000 draws.

<center>
![](assets/length-middle-95-quantile.svg)
</center>

Then, we will transform the data we get from these distributions and the above graph to explore the relationship between the density, or relative likelihood and the corresponding *p*<sup>*t**h*</sup> quantile from the previous figure. The x-axis on this figure is a transformation of the x-axis from the previous figure.

<center>
![](assets/length-middle-95-density.svg)
</center>

Using the above figures, we will be able to answer the following questions:

1. Which quantiles have greater precision? 
2. When does the median has the tightest distribution?
3. How do the results change for different values of N (changing sample size from 200 to 400, 800 and 1600)?

# Distribution 1 - Standard Normal Distribution

In order to make the following computations for each of the types of distributions easier, we will first create a function that can take in certain parameters and give an output of the length of the middle 95% of the sampling distribution for a set of quantiles. 

We first need to be able to generate the length of the middle 95% of the sampling distribution for a single quantile. The quantiles that we will be sampling for in this post are 0.05, 0.20, 0.35, 0.5, 0.65, 0.80, and 0.95. 

In the code below, I create a function called single_quantile, that takes in 4 parameters; 'n', which is the sample size, the number of draws in the sampling distribution, quant, the quantile being tested and the type of distribution we are testing for. In the function, we first create a blank vector that is the length of the number of draws. We then iterate through a for loop for each draw. In this for loop, we first check which type of distribution we are testing for, and then follow the steps used to calculate the result for each of the distributions. In the case of the Standard Normal Distribution, we are using the rnorm function to generate a random normal distribution. Similarly, for the Exponential distribution, we use the rexp function to generate the distribution. The mixed normal and mixed beta functions are more complicated and are further discussed in the corresponding sections. 

Once the type being used has been determined, we run the distribution generation function for the given type, in this case, rnorm, with the given sample size "n". We store this distribution in a data frame called nd (normal distribution). We then use the R quantile function to calculate that quantile of the distribution being tested for, storing this in dataframe qd. We then use the quantile functions to calculate the length of the middle 95% of the sampling distribution stored in qd by calculating the difference between 2.5% and 97.5% percentiles of the sampling distribution using the quantile function. The single_quantile function then returns the length of the middle 95% of the distribution as a numeric. 

```{r single_quantile_function}

single_quantile <- function(n, draws, quant, type) {
  qd <- rep(NA, draws)
  for (i in 1:draws) {
    if (type == "normal") {
      nd <- rnorm(n)
      qd[i] <- quantile(nd, quant)
    } else if (type == "exponential") {
      nd <- rexp(n)
      qd[i] <- quantile(nd, quant)
    } else if (type == "mixture_normal") {
      nd <- rf3(n)
      qd[i] <- quantile(nd, quant)
    } else if (type == "mixture_beta") {
      nd <- rf4(n)
      qd[i] <- quantile(nd, quant)
    } else {
      return(NULL)
    }
  }
  length25 <- quantile(qd, 0.025)
  length975 <- quantile(qd, 0.975)
  difference <- abs(length975 - length25)
  return(as.numeric(difference))
}

single_quantile(200, 5000, 0.95, "normal")
```

Now that we have a function that can calculate the length of the middle 95% of the sampling distribution for a particular quantile, we can create a function that will be able to generate a length for multiple quantiles. Below, I create a function called quantilelength that takes in the same variables as single_quantile, but iterates the single_quantile function in a for loop for the length of a vector containing multiple quantiles being tested for. The function returns a vector called qlength that contains the lengths of the middle 95% of the distribution for multiple quantiles. 

``` {r quantile_length_function}
quantiles <- c(0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.5, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95)

quantilelength <- function (n, draws, quant, type) {
  qlength <- rep(NA, length(quant))
  for (i in seq_along(quant)) {
    qlength[i] <- single_quantile(n, draws, quant[i], type)
  }
  return(qlength)
} 

q1 <- quantilelength(200, 5000, quantiles, "normal")

plot(quantiles, q1, type = "o", pch = 16, ylab = "Length", xlab = expression("p"^th*"quantile")) 

```

The above graph demonstrates that in a standard normal distribution, the length of the middle 95% of the sample distribution decreases as you approach the mean. The mean usually has one of the lowest values of length in a standard normal distribution, ie. the median has the tightest distribution in a normal distribution. 

Now, to understand the relationship between density and the corresponding quantile, we just need to transform our x-axis values. We first use the qnorm function and dnorm function on the list of quantiles being tested for to generate a list of densities. I created a function called density that takes in a vector of quantiles and the type (either exponential or normal) of distribution. I use toe qnorm and dnorm function to calculate the density for the normal distribution and the qexp and dexp functions for the exponential distributions. 

```{r normal_density}
density <- function(quant, type) {
  densq <- rep(NA, length(quant))
  density.quantiles <- rep(NA, length(quant))
  if (type == "normal") {
    for (i in seq_along(quant)) {
      densq[i] <- qnorm(quant[i])
      density.quantiles[i] <- dnorm(densq[i])
    }
    return(density.quantiles)
  }
  else if (type == "exponential") {
    for (i in seq_along(quant)) {
      densq[i] <- qexp(quant[i])
      density.quantiles[i] <- dexp(densq[i])
    }
    return(density.quantiles)
  }
}

densitiesn <- density(quantiles, "normal")
densitiesn

plot(densitiesn, q1, type = "p", pch = 16, xlab = "Density", ylab = "Length")
```

As can be seen from the graph above, the length of the middle 95% of the sample distribution decreases as the density increases. 

```{r notes, include=FALSE}
#Notes

#distribution <- function(n, draws, quartile) {
#  qd <- rep(NA, draws)
#  for (i in 1:draws) {
#    nd <- rnorm(n)
#    qd[i] <- quantile(nd, quartile)
#  }
#  length25 <- quantile(qd, 0.025)
#  length975 <- quantile(qd, 0.975)
#  difference <- abs(length975 - length25)
#  return(as.numeric(difference))
#}

#qd <- rep(NA, 5)
#  for (i in 1:5) {
#    nd <- rnorm(200)
#    qd[i] <- quantile(nd, 0.05)
#  }
#  length25 <- quantile(qd, 0.025)
#  length975 <- quantile(qd, 0.975)
#  difference <- abs(length975 - length25)



#distribution <- function(n, draws, quartiles) {
#  qd <- rep(NA, draws)
#  for (i in seq_along(n)) {
#    for (j in 1:draws) {
#      for (k in seq_along(quartiles)) {
#        nd <- rnorm(n)
#        qd[j] <- quantile(nd, quartiles[k])
#      }
#    }
#  }
#  return(qd)
#}
#n <- c(200)
#quartiles <- c(0.05, 0.20, 0.35, 0.5, 0.65, 0.80, 0.95)
#distribution(200, 5, quartiles)




#N <- 200
#draws <- 5
#qd <- rep(NA, draws)
#for (i in 1:draws) {
#  nd <- rnorm(N)
#  qd[i] <- quantile(nd, 0.005)
#}


#length25 <- function(x) {
#  quantile(x, 0.025)
#}


#nd <- rep(NA, length(quartiles))
#for (i in seq_along(quartiles)) {
#  nd[i] <- distribution(200, 5000, quartiles[i], "normal")
#}
#nd

#multilength <- sapply(mylist.names, function(x) NULL)
#for (i in seq_along(n)) {
#  multilength[[i]] <- quartilelength(n[i],5000,quartiles,"normal")
#}

#mylist.names <- c("200", "400","800","1600")
```

# Distribution 2 - Exponential Distribution

As we created a function that is able to take in the type of disitribution being tested for, we use the same quantilelength function, indicating that the type is "exponential". 

```{r exponential}

q2 <- quantilelength(200, 5000, quantiles, "exponential")

densitiese <- density(quantiles, "exponential")

plot(quantiles, q2, type = "o", pch = 16, ylab = "Length", xlab = expression("p"^th*"quantile"))
plot(densitiese, q2, type = "o", pch = 16, xlab = "Density", ylab = "Length")

```

As can be seen from the graph above, the length of the middle 95% of the sample distribution increases as you move towards the higher quantiles. The opposite relationship is true for the case of density. As density increases, the length of the middle 95% of the distribution decreases. 

# Distribution 3 - Mixture Distribution using Normal Distributions

The mixture distribution using nomral distributions is also built into the quantilelength function as seen above. Here, let's see what function is being used to generate the mixture distribution. The function rf3 creates a mixture distribution by sampling and combining 3 different standard normal distributions. The process of finding the density is different for mixture distributions as you cannot just add the inverses for each of the parts of the distribution. I create a function called den1 that calculates the root for the corresponding quantiles using the pf3 function and the uniroot function. These roots are then transformed using the df3 function to create a vector densitiesMN containing the densities for the associated quantiles. 

```{r mixture_normal}

rf3 <- function(N){
  G <- sample(0:2, N, replace = TRUE, prob = c(5,3,2))
  (G==0)*rnorm(N) + (G==1)*rnorm(N,4) + (G==2)*rnorm(N,-4,2)
}

pf3 <- function(x){
  .5*pnorm(x) + .3*pnorm(x,4) + .2*pnorm(x,-4,2)
}

df3 <- function(x){
  .5*dnorm(x) + .3*dnorm(x,4) + .2*dnorm(x,-4,2)
}

den1 <- function(quant) {
  df <- rep(NA, length(quant))
  root <- rep(NA, length(quant))
  for (i in seq_along(quant)) {
     df <- function (x) pf3(x) - quant[i]
    root[i] <- uniroot(df, c(-1000,1000))[[1]]
  }
  return(root)
}

dens <- den1(quantiles)
densitiesMN <- rep(NA, length(dens))
for (i in seq_along(dens)) {
  densitiesMN[i] <- df3(dens[i])
}
densitiesMN

rf3(100000) %>% range()

q3 <- quantilelength(200, 5000, quantiles, "mixture_normal")

plot(quantiles, q3, type = "o", pch = 16, ylab = "Length", xlab = expression("p"^th*"quantile"))
plot(densitiesMN, q3, type = "p", pch = 16, xlab = "Density", ylab = "Length")
```

This particular mixture distribtion follows a pattern where the length decreases as you approach the median, but increases again towards the 75th percentile and decreases again to a low towards the 90th percentile. Generally, the length decreases as density increases. 

## Distribution 4 - Mixture Distribution using Beta Distributions

The mixture distribution using beta distributions is also built into the quantilelength function as seen above. Here, let's see what function is being used to generate the mixture distribution. The function rf4 creates a mixture distribution by sampling and combinin2 different beta distributions distributions. The density function den2 follows the same principles of the function den1 to calculate the root of the quantiles. Those roots are then transformed using the df4 function to calculate the corresponding densities. 

```{r mixture_beta}

rf4 <- function(N){
  G <- sample(0:1, N, replace = TRUE)
  (G==0)*rbeta(N,5,1) + (G==1)*rbeta(N,1,5)
}

pf4 <- function(x){
  .5*pbeta(x,5,1) + .5*pbeta(x,1,5)
}

df4 <- function(x){
  .5*dbeta(x,5,1) + .5*dbeta(x,1,5)
}

den2 <- function(quant) {
  df <- rep(NA, length(quant))
  root <- rep(NA, length(quant))
  for (i in seq_along(quant)) {
     df <- function (x) pf4(x) - quant[i]
    root[i] <- uniroot(df, c(-1000,1000))[[1]]
  }
  return(root)
}
dens2 <- den2(quantiles)
densitiesBD <- rep(NA, length(dens2))
for (i in seq_along(dens2)) {
  densitiesBD[i] <- df4(dens2[i])
}
densitiesBD

q4 <- quantilelength(200, 5000, quantiles, "mixture_beta")
plot(quantiles, q4, type = "o", pch = 16, ylab = "Length", xlab = expression("p"^th*"quantile"))
plot(densitiesBD, q4, type = "p", pch = 16, xlab = "Density", ylab = "Length")
```

In the case of this mixture distribution, the length increases towards the median to a maximum and decreases towards the tails. Generally, as density increases, length decreases. 

## Changing Sample Size

To understand how changing the sample size affects the uncertainties in the quantiles, we can create a function that runs the quantilelength function for different samples sizes. The multilength function below takes in the same parameters as the quantilelength function, but runs the quantilelength function over a for loop iterating through a vector multin containing different sample sizes being tested for. The function returns a list of the lengths of the middle 95% of each of the quantiles and sample sizes being tested for. We can then plot these lengths on a single graph to determine how changing the sample size affects the length of the middle 95% of the sample distribution. 

```{r sample_size}

multin <- c(200, 400, 800, 1600)

multilength <- function(n, draws, quart, type) {
  mylist.names <- c("200", "400", "800", "1600")
  nlengths <- sapply(mylist.names, function(x)
    NULL)
  for (i in seq_along(n)) {
    nlengths[[i]] <- quantilelength(n[i], draws, quart, type)
  }
  return(as.data.frame(nlengths))
}

multiplot <- multilength(multin, 5000, quantiles, "normal")
multiplot

ggplot(multiplot) + 
  geom_line(aes(y = X200, x = quantiles, colour = "n = 200")) + 
  geom_line(aes(y = X400, x = quantiles, colour = "n = 400")) +
  geom_line(aes(y = X800, x = quantiles, colour = "n = 800")) +
  geom_line(aes(y = X1600, x = quantiles, colour = "n = 1600")) + 
  scale_color_discrete(name = "Sample Size") +
  labs(x = "Quantiles", y = "Length")


ggplot(multiplot) + 
  geom_line(aes(y = X200, x = densitiesn, colour = "n = 200")) +
  geom_point(aes(y = X200, x = densitiesn, colour = "n = 200")) +
  geom_line(aes(y = X400, x = densitiesn, colour = "n = 400")) +
    geom_point(aes(y = X400, x = densitiesn, colour = "n = 400")) +
  geom_line(aes(y = X800, x = densitiesn, colour = "n = 800")) +
    geom_point(aes(y = X800, x = densitiesn, colour = "n = 800")) +
  geom_line(aes(y = X1600, x = densitiesn, colour = "n = 1600")) +
  geom_point(aes(y = X1600, x = densitiesn, colour = "n = 1600")) + 
  scale_color_discrete(name = "Sample Size") +
  labs(x = "Density", y = "Length")
```

As can be seen from the graph above, as the sample size is increased, the length of the middle 95% of the decreases as the sample size increases, and follows the same pattern in general for each sample size. This makes sense as the sample size increases, uncertainty decreases in estimates of quartiles. Changing sample size and the relationship between density and length follows the same trend, where increasing sample size leads to a decrease in length, but following the same trend of decreasing length as density increases. 

## When does the median have the tightest distribution?

As can be interpreted from the graphs above, the lowest length value seen for the median can be seen in normal distributions. The opposite is true for the mixture beta distribution, where the length of the middle 95% of the distribution is the longest at the median.

